#+TITLE: Clojure Notes
#+DESCRIPTION: Notes from studying Clojure

#+HTML_DOCTYPE: html5
#+HTML_LINK_UP: ./index.html
#+HTML_LINK_HOME: ./index.html
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="./static/worg.css" />
#+HTML_MATHJAX: path: "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"
#+OPTIONS: html-style:nil
#+OPTIONS: num:nil

* Preface

These are notes on Clojure - as I learn it. (I'm starting with knowing ELisp already).
Copying most code from Clojure for the Brave and True and adding some extra tidbits I
find

* Setup

You need to install =leiningen= and =clojure= and =openjdk= to get started. =leiningen=
generates your project directories (this shouldn't be done manually for some reason)

#+BEGIN_SRC sh
lein new app you-application-name
#+END_SRC

The entry point of the new project will be in =/src/your-application-name/core.clj=

* Control Flow

** if
~(if boolean-form then-form optional-else-form)~
#+BEGIN_SRC clojure
  (if true
    "By Zeus' hammer!"
    "By Aquaman's trident")
  ;; -> "By Zeus' hammer
#+END_SRC

** do
~(do thing1 thing2 ..)~ \\
/executes multiple things in a place that expects on. The last thing will be the return value/
#+BEGIN_SRC clojure
  (if true
    (do (println "Success!")
        "By Zeus' hammer!")
    (do (println "Failure!")
        "By Aquaman's trident!")
    ;; => Success!
    ;; => "By Zeus' hammer!"
#+END_SRC

** when
~(when test thing1 thing2 ..)~ \\
/evaluates test. If logical true, evaluates body in an implicit do./
#+BEGIN_SRC clojure
  (when true
    (println "Success!")
    "abra cadabra")
#+END_SRC

* Data Structures

** numbers
+ integer: =3=
+ floating: =3.0=
+ fraction: =30/10=

** maps - {}
Not to be confused with the ~map~ higher-order-function. \\
/a collection of pairs of keys and items. both can be anything/
#+BEGIN_SRC clojure
  {:first-name "Charlie"
   :last-name "McFishwich"}

  {"string-key" +} ;; weird example. the key is a string and the item is the + symbol
#+END_SRC
~(get map key) or (get map key fallback)~
#+BEGIN_SRC clojure
  (get {:a 0 :b 1} :b)
  ;; => 1
  (get {:a 0 :b {:c "ho hum"}} :b)
  ;; => {:c "ho hum"}
  (get {:a 0 :b 1} :c)
  ;; => nil

  ;; using a default/fallback value
  (get {:a 0 :b 1} :c "fallback unicorns")
  ;; => "fallback unicorns"
#+END_SRC
/a more short-hand way of doing the same.. use the map as a function itself/
~({map} key)~
#+BEGIN_SRC clojure
  ({:name "The Human Coffeepot"} :name)
  ;; => "The Human Coffeepot"
#+END_SRC

*** keywords
   these are like special keys that can also be used as a function to retrieve items in a map. So sorta inverting the last example \\
   ~(keyword map) or (keyword map fallback)~
#+BEGIN_SRC clojure
  (:a {:a 1 :b 2 :c 3})
  ;; => 1

  (:d {:a 1 :b 2 :c 3} "more fallback unicorns")
  ;; => "more fallback unicorns"
#+END_SRC

** vector - []
#+BEGIN_SRC clojure
  [3 2 1]

  (get [3 2 1] 0)

  (get ["a" {:name "Pugsley"} "c"] 1)
  ;; => {:name "Pugsley"}

  (vector "creepy" "full" "moon")
  ;; => ["creepy" "full" "moon"]

  (conj [1 2 3] 4)
  ;; => [1 2 3 4]
#+END_SRC

** lists - '()
#+BEGIN_SRC clojure
  '(1 2 3 4)
  ;; => (1 2 3 4)

  (nth '(:a :b :c) 2)
  ;; =? :c

  (list 1 "two" {3 4})
  ;; => (1 "two {3 4})

  (conj '(1 2 3) 4)
  ;; => (4 1 2 3)
  ;; NOTICE! Goes to the front!
#+END_SRC
#+TITLE: Clojure Notes
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://geokon-gh.github.io/static/worg.css" />
#+options: num:nil toc:nil


* Preface

These are notes on Clojure - as I learn it. (I'm starting with knowing ELisp already).
Copying most code from Clojure for the Brave and True and adding some extra tidbits I
find

* Setup

You need to install =leiningen= and =clojure= and =openjdk= to get started. =leiningen=
generates your project directories (this shouldn't be done manually for some reason)

#+BEGIN_SRC sh
lein new app you-application-name
#+END_SRC

The entry point of the new project will be in =/src/your-application-name/core.clj=

* Control Flow

** if
~(if boolean-form then-form optional-else-form)~
#+BEGIN_SRC clojure
  (if true
    "By Zeus' hammer!"
    "By Aquaman's trident")
  ;; -> "By Zeus' hammer
#+END_SRC

** do
~(do thing1 thing2 ..)~ \\
/executes multiple things in a place that expects on. The last thing will be the return value/
#+BEGIN_SRC clojure
  (if true
    (do (println "Success!")
        "By Zeus' hammer!")
    (do (println "Failure!")
        "By Aquaman's trident!")
    ;; => Success!
    ;; => "By Zeus' hammer!"
#+END_SRC

** when
~(when test thing1 thing2 ..)~ \\
/evaluates test. If logical true, evaluates body in an implicit do./
#+BEGIN_SRC clojure
  (when true
    (println "Success!")
    "abra cadabra")
#+END_SRC

* Data Structures

** numbers
+ integer: =3=
+ floating: =3.0=
+ fraction: =30/10=

** maps - {}
Not to be confused with the ~map~ higher-order-function. \\
/a collection of pairs of keys and items. both can be anything/
#+BEGIN_SRC clojure
  {:first-name "Charlie"
   :last-name "McFishwich"}

  {"string-key" +} ;; weird example. the key is a string and the item is the + symbol
#+END_SRC
~(get map key) or (get map key fallback)~
#+BEGIN_SRC clojure
  (get {:a 0 :b 1} :b)
  ;; => 1
  (get {:a 0 :b {:c "ho hum"}} :b)
  ;; => {:c "ho hum"}
  (get {:a 0 :b 1} :c)
  ;; => nil

  ;; using a default/fallback value
  (get {:a 0 :b 1} :c "fallback unicorns")
  ;; => "fallback unicorns"
#+END_SRC
/a more short-hand way of doing the same.. use the map as a function itself/
~({map} key)~
#+BEGIN_SRC clojure
  ({:name "The Human Coffeepot"} :name)
  ;; => "The Human Coffeepot"
#+END_SRC

*** keywords
   these are like special keys that can also be used as a function to retrieve items in a map. So sorta inverting the last example \\
   ~(keyword map) or (keyword map fallback)~
#+BEGIN_SRC clojure
  (:a {:a 1 :b 2 :c 3})
  ;; => 1

  (:d {:a 1 :b 2 :c 3} "more fallback unicorns")
  ;; => "more fallback unicorns"
#+END_SRC

** vector - []
#+BEGIN_SRC clojure
  [3 2 1]

  (get [3 2 1] 0)

  (get ["a" {:name "Pugsley"} "c"] 1)
  ;; => {:name "Pugsley"}

  (vector "creepy" "full" "moon")
  ;; => ["creepy" "full" "moon"]

  (conj [1 2 3] 4)
  ;; => [1 2 3 4]
#+END_SRC

** lists - '()
#+BEGIN_SRC clojure
  '(1 2 3 4)
  ;; => (1 2 3 4)

  (nth '(:a :b :c) 2)
  ;; =? :c

  (list 1 "two" {3 4})
  ;; => (1 "two {3 4})

  (conj '(1 2 3) 4)
  ;; => (4 1 2 3)
  ;; NOTICE! Goes to the front!
#+END_SRC
** sets - #{}
/collection of unique values/
#+BEGIN_SRC clojure
#{"kurt" 20 :icicle}

(hash-set 1 1 2 2)
;; => #{1 2}

(conj #{:a :b}:b)
;; => #{:a :b}

(set [3 3 3 4 4])
;; => #{3 4}

(contains? #{:a :b} :a)
;; => true

(:a #{:a :b})
;; => :a

(get #{:a :b} :a)
;; => :a

(get #{:a nil} nil)
;; => nil

(get #{:a :b} "kurt")
;; => nil
#+END_SRC

* Functions

** overloading
/done on argument/
#+BEGIN_SRC clojure
  (defn x-chop
    "Describe the kind of chope you inflict"
    ([name chop-type]
     (str "I " chop-type " chop" name "! Take that!"))
    ([name]
     (x-chop name "karate")))
#+END_SRC
** variable arity
~[& remainding-items]~ 
/and they are treated as a collection that you can use ~map~ on/
#+BEGIN_SRC clojure
  (defn codger-communication
    [whippersnapper]
    (str "Get off my lawn, " whippersnapper "!!!"))

  (defn codger
    [& whippersnappers]
    (map codger-communication whippersnappers))
  (codger "Billy" "Ann-Marie" "The Incredible Bulk")
  ;; => ("Get off my lawn, Billy!!!"
  ;;     "Get off my lawn,  Anne-Marie!!!"
  ;;     "Get off my lawn,  The Incredible Bulk")
#+END_SRC
** private functions
/exclusive to a namespace/
~(defn- privatefn)~
#+BEGIN_SRC clojure
  (defn- private-function
    "Just an empty example"
    [])
#+END_SRC
** destructuring
/extracts things right in the argument declaration/
*** first element
#+BEGIN_SRC clojure
  (defn my-first
    [[first-thing]]
    first-thing)

  (my-first ["over" "bike" "war-axe"])
  ;; => oven
#+END_SRC
*** vectors and variable arity
/sequencially match vector elements to indices in order. remainer placed with an ampersand/
#+BEGIN_SRC clojure
  (defn chooser
  [[first second &other-stuff]]
    (println (str "first thing was :" first))
    (println (str "second was :" second))
    (println (str "and the rest was  :" 
                  (clojure.string/join ", " other-stuff))))

(chooser ["icecream", "cake", "apples", "lettuce"])
;; => first thing was: icecream
;; => second was: cake
;; => and the rest was : apples, lettuce
#+END_SRC
*** maps and keywords
#+BEGIN_SRC clojure


#+END_SRC
/assign the map values as the given keys to the matching symbol/
#+BEGIN_SRC clojure
  (defn announce-treasure-location
    [{lat :lat lng :lng}]
    (print (str "Treasure lat: " lat))
    (print (str "Treasure lng: " lng)))

  (announce-treasure-location {:lat 28.22 :lng 81.33})
  :; => Treasure lat : 28.22
  ;; => Treasure lng: 81.33
#+END_SRC
/or automatically make the assigned symbols match the keyword in the map/
#+BEGIN_SRC clojure
  (defn announce-treasure-location
    [{:keys [lat lng]}]
    (print (str "Treasure lat: " lat))
    (print (str "Treasure lng: " lng)))

  (announce-treasure-location {:lat 28.22 :lng 81.33})
  :; => Treasure lat : 28.22
  ;; => Treasure lng: 81.33
#+END_SRC
/if you still need the un-destructured input map you can use the :as keyword/
#+BEGIN_SRC clojure
  (defn announce-treasure-location
    [{:keys [lat lng] :as treasure-location}]
    (print (str "Treasure lat: " lat))
    (print (str "Treasure lng: " lng))
    (steer-ship! treasure-location)) ;; <- we still want the input/map here!

  (announce-treasure-location {:lat 28.22 :lng 81.33}

  :; => Treasure lat : 28.22
  ;; => Treasure lng: 81.33
#+END_SRC
** anonymous
/create in-place functions with no name/
#+BEGIN_SRC clojure
  (fn [param-list]
    function body)
#+END_SRC
example: feeding into the ~(map)~
#+BEGIN_SRC clojure
  (map (fn [name] (str "Hi, " name))  ;; <- apply this function
       ["Darth Vader" "Mr. Magoo"])   ;; <- on these inputs

#+END_SRC
/shorthand:/
#+BEGIN_SRC clojure
#(* % 3) ;; same as (fn [x] (* x 3))

(#(* % 3) 8) ;; applied to the number 8
;; => 24
#+END_SRC
** recusion
/needs to be stated explicitly with (recur)/
#+BEGIN_SRC clojure
  (defn sum
    ([vals] (sum vals 0))
    ([vals accumulating-total]
     (if (empty? vals)
       accumulating-total
       (recur (rest vals) 
              (+ (first vals) accumulating-total))))) 
;; this calls the second overload with 2 args
#+END_SRC
* Datatypes
** multimethods
We declare a multimethod with ~defmulti~ which defines the signature and the *dispatch function* for the multimethod. The return value of the dispatch function will need to match a method defined with ~defmethod~

* Notes on performance

From: https://reddit.com/comments/a2ubj8/comment/eb2qthy

#+BEGIN_QUOTE
You're causing reflection by invoking the .contains method on an unhinted var.  The compiler can't figure out whether the method exists at compile time, so has to resort to invoking clojure.lang method reflectors over and over to lookup the method on the object using java reflection.  This is a canonical source of drastic overhead.

First pass:

    (set! *warn-on-reflection* true)

Will provide warnings where your code is causing reflection, and likely orders of magnitude slowdown.

The fix (for this) is to avoid reflection via type-hints, or better yet, use built-in functions that provide the functionality and/or already have hints in place for you....You could throw a type-hint into the existing code and see if that eliminates reflection (one source of slowdown, maybe enough to get you reasonable speed).

    ;;fix reflection (but not algorithmic complexity) and not
    ;;idiomatic.
    (.contains ^clojure.lang.PersistentVector frequencies new-frequency)
    ;;or use some (there are likely other sequence libraries)
    (some #{new-frequency} frequencies)

I haven't looked at the AOC day 1 problem, but your use-case looks like maybe a set datastructure would be better than a vector in this case.  If you're checking for membership in a set of numbers, maintaining a set/map/sorted set would likely be better than repeatedly scanning through collection in linear time (may depend on problem size though, small linear scans can be faster in some cases).

Other potential problems: you're using O(N) operations in some cases.  nth, when used on a sequence, is O(N) vs. ~O(1) for a vector or array.  count is similarly potentially slow depending on datatype (although I think count will cache its result for a sequence, but in the worst case, you could also be doing additional O(N) counts every iteration....)  So every time you scan, you have to repeatedly traverse the changes sequence that you read in.  You can avoid this by ensuring that changes is a vector, which will regain lookup efficiency.  Either return a vector from get-numbers, or coerce the get-numbers call to a vec...

Just looking at the uses here, I think there's a better approach (algorithmically speaking) than repeated linear scans, with linear lookups, to satisfy the criteria.  However, for the problem size, it may end up being just fine if you fix the reflection warning :)  I'd be tempted to look at expressing the problem using loop/recur, reduce, and other variants to learn, as well as optimize.
#+END_QUOTE
